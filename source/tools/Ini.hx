package tools;

/**
 * MISSING:
 * - Nested arrays
 * - Comments in-line with key-value pairs
 * - Multiple key-value pairs in a single line
 * - Sub-sections
 */

/**
 * Simple INI parsing implementation.
 */
class Ini {
    /**
     * Parses INI content from a file and converts it into readable Haxe values.
     * @param path Path to the file.
     * @param allowArrays Whether to allow array parsing.
     * @return Parsed INI data.
     */
    public static inline function parseFile(path:String, allowArrays:Bool = false):IniData {
        return parse(sys.io.File.getContent(path), allowArrays);
    }

    /**
     * Parses an INI document and converts it into readable Haxe values.
     * @param content Content of the file.
     * @param allowArrays Whether to allow array parsing.
     * @return Parsed INI data.
     */
    public static function parse(content:String, allowArrays:Bool = false):IniData {
        var parser:Ini = new Ini();
        parser.allowArrays = allowArrays;

        var output:IniData = parser.parseString(content);
        parser.clean();
        return output;
    }

    /**
     * Output generated by this INI parser.
     */
    public var output(default, null):IniData;

    /**
     * Whether to allow array parsing.
     */
    public var allowArrays:Bool = false;

    /**
     * Internal, stores the current parsed section.
     */
    var _currentSection:String;

    /**
     * Internal, stores the current line being parsed. Used to throw errors in case of parsing failure.
     */
    var _currentLine:Int;

    /**
     * Creates a new `Ini` parser.
     */
    public function new():Void {}

    /**
     * Parses a string INI structure and converts it into an Haxe object.
     * @param content String to parse.
     * @return Parsed INI data.
     */
    public function parseString(content:String):IniData {
        _currentSection = "global";
        _currentLine = 1;

        output = new IniData();
        output.set(_currentSection, new StringMap<Any>());

        for (line in content.split("\n"))
            parseLine(line);

        return output;
    }

    /**
     * Clean up memory allocated by this parser.
     */
    public function clean():Void {
        _currentSection = null;
        output = null;
    }

    /**
     * Method which parses a line from an INI structure.
     * @param line Line to parse.
     */
    function parseLine(line:String):Void {
        line = line.trim();

        // skip empty lines
        if (line.length == 0) {
            _currentLine++;
            return;
        }

        // skip comments
        if (line.startsWith(";") || line.startsWith("#")) {
            _currentLine++;
            return;
        }

        // handle sections
        if (line.startsWith("[")) {
            // could not close section, throw an error
            if (!line.endsWith("]")) {
                throw "Missing section end bracket at line " + Std.string(_currentLine);
            }

            var section:String = line.substring(1, line.length - 1);

            // duplicate section, throw an error
            if (output.exists(section)) {
                throw 'Duplicate section "${section}" at line ' + Std.string(_currentLine);
            }

            registerSection(section);
            _currentLine++;
            return;
        }

        // handle key value pairs
        if (!line.contains("=")) {
            // no key value pair found, throw an error
            throw "Missing key value pair at line " + Std.string(_currentLine);
        }

        var keyValuePairs:Array<String> = line.split("=");
        
        for (i in 0...Math.floor(keyValuePairs.length / 2)) {
            var key:String = keyValuePairs[i * 2].trim();
            var value:String = keyValuePairs[i * 2 + 1].trim();

            output[_currentSection].set(key, parseExpression(value));
        }

        _currentLine++;
    }

    /**
     * Handles INI sections and subsections.
     * @param section Section to register.
     */
    function registerSection(section:String):Void {
        // if (!section.contains(".")) {
            _currentSection = section;
            output.set(_currentSection, new StringMap<Any>());
            // return;
        // }

        /*
        var subs:Array<String> = section.split(".");
        if (subs.length == 1 && section.startsWith(".")) {
            _currentSection = section.substring(1, _currentSection.length);
            return;
        }
        */
    }

    /**
     * Parses an INI expression and converts it into an Haxe value.
     * @param expr Expression to parse.
     * @return Parsed expression.
     */
    function parseExpression(expr:String):Any {
        static final NUMBER_EXPR:EReg = ~/^[0-9.]*$/;

        // null expression
        if (expr == "null")
            return null;

        // bool expression
        if (expr == "true" || expr == "false")
            return expr == "true";

        // number expression
        if (NUMBER_EXPR.match(expr))
            return Std.parseFloat(expr);

        // array expression
        if (allowArrays && expr.startsWith("[") && expr.endsWith("]")) {
            var array:Array<Any> = [];
            for (value in expr.substring(1, expr.length - 1).split(","))
                array.push(parseExpression(value.trim()));
            return array;
        }

        // string with quotes expression
        if ((expr.startsWith('"') && expr.endsWith('"')) || (expr.startsWith("'") && expr.endsWith("'")))
            return expr.substring(1, expr.length - 1);

        // string expression
        return expr;
    }
}

typedef IniData = StringMap<StringMap<Any>>;